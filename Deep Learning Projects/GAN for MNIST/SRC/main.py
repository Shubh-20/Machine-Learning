# -*- coding: utf-8 -*-
"""
Created on Sun Nov  1 22:06:32 2020

@author: Shubham
"""
#%% Importing all Libraries
import torch
import torch.nn as nn
import torchvision.transforms as transforms
import torch.optim as optim
import torchvision.datasets as datasets 
import imageio
import numpy as np
import matplotlib

from torchvision.utils import make_grid, save_image
from torch.utils.data import DataLoader
from matplotlib import pyplot as plt
from tqdm import tqdm

matplotlib.style.use('ggplot')

#%% Defining Learning Parameters
batch_size = 512
epochs = 200
sample_size = 64 # Fixed sample size
nz = 128 # Latent vector size
k = 1 # Number of steps to apply to the discriminator
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

#%% Preparing the Dataset
transform = transforms.Compose([
                                transforms.ToTensor(),
                                transforms.Normalize((0.5,), (0.5, ))])
to_pil_image = transforms.ToPILImage()

#%% Loading the data
train_data = datasets.MNIST(root='../Inputs/data',
                             train=True,
                             download=True,
                             transform=transform)
train_loader = DataLoader(train_data, batch_size=batch_size,shuffle=True)

#%% Defining the Generator Neural Network
class Generator(nn.Module):
    def __init__(self, nz):
        super(Generator, self).__init__()
        self.nz = nz
        self.main = nn.Sequential(
            nn.Linear(self.nz, 256),
            nn.LeakyReLU(0.2),
            
            nn.Linear(256, 512),
            nn.LeakyReLU(0.2),
            
            nn.Linear(512, 1024),
            nn.LeakyReLU(0.2),
            
            nn.Linear(1024, 784),
            nn.Tanh())
    def forward(self, x):
        return self.main(x).view(-1, 1, 28, 28)

#%% Defining the Discriminator network
"""
The discriminator is a binary classifier so 
keep that in mind while defining the NN
"""
class Discriminator(nn.Module):
    def __init__(self):
        super(Discriminator, self).__init__()
        self.n_input = 784
        self.main = nn.Sequential(
            nn.Linear(self.n_input, 1024),
            nn.LeakyReLU(0.2),
            nn.Dropout(0.3),
            
            nn.Linear(1024, 512),
            nn.LeakyReLU(0.2),
            nn.Dropout(0.3),
            
            nn.Linear(512, 256),
            nn.LeakyReLU(0.2),
            nn.Dropout(0.3),
            
            nn.Linear(256, 1),
            nn.Sigmoid())
    def forward(self, x):
        x = x.view(-1, 784)
        return self.main(x)

#%% Initialize the Neural Network and define the Optimizer
generator = Generator(nz).to(device)
discriminator = Discriminator().to(device)

print('#### GENERATOR #####')
print(generator)
print('##############')

print('\n#### DESCRIMINATOR ####')
print(discriminator) 
print('###########')
# Optimizer
optim_g = optim.Adam(generator.parameters(), lr = 0.00002)
optim_d = optim.Adam(discriminator.parameters(), lr = 0.00002)
# Loss
criterion = nn.BCELoss()


#%% Things to save
losses_g = [] # to store generator loss after each epoch
losses_d = [] # to store discriminator loss after each epoch
images = [] # to store images generated by the generator

#%% Some utility functions
# to create real labels(1s)
def label_real(size):
    data = torch.ones(size, 1)
    return data.to(device)

# to create fake labels (0s)
def label_fake(size):
    data = torch.zeros(size, 1)
    return data.to(device)

# function to create noise
def create_noise(sample_size, nz):
    return torch.randn(sample_size, nz).to(device)

# to save the images in a grid generated by the generator
def save_generator_images(image, path):
    save_image(image, path)


#%% Function to train the discriminator
def train_discriminator(optimizer, data_real, data_fake ):
    b_size = data_real.size(0)
    real_label = label_real(b_size)
    fake_label = label_fake(b_size)
    
    optimizer.zero_grad()
    
    output_real = discriminator(data_real)
    loss_real = criterion(output_real, real_label)
    
    output_fake = discriminator(data_fake)
    loss_fake = criterion(output_fake, fake_label)
    
    loss_real.backward()
    loss_fake.backward()
    optimizer.step()
    
    return loss_real + loss_fake

#%% Function to train the generator
def train_generator(optimizer, data_fake):
    b_size = data_fake.size(0)
    real_label = label_real(b_size)
    
    optimizer.zero_grad()
    
    output = discriminator(data_fake)
    loss = criterion(output, real_label)
    
    loss.backward()
    optimizer.step()
    
    
    return loss

#%% Training the GAN
# Create the noise vector
noise = create_noise(sample_size, nz)

generator.train()
discriminator.train()

#%% The training Loop
for epoch in range(epochs):
    loss_g = 0.0
    loss_d = 0.0
    for bi, data in tqdm(enumerate(train_loader), total=int(len(train_data)/train_loader.batch_size)):
        image, _ = data
        image = image.to(device)
        b_size = len(image)
        # Run the discriminator for k number of steps
        for step in range(k):
            data_fake = generator(create_noise(b_size, nz)).detach()
            data_real = image
            # train the discriminator network
            loss_d += train_discriminator(optim_d, data_real, data_fake)
            
        data_fake = generator(create_noise(b_size, nz))
        #train the generator network
        loss_g += train_generator(optim_g, data_fake)
        
    # Create the final fake image for the epoch
    generated_img = generator(noise).cpu().detach()
    #make images as a grid 
    #generated_img = make_grid(generated_img)
    #save the torch tensor model to disk
    save_generator_images(generated_img, '../Output/gen_img{epoch}.png')
    images.append(generated_img)
    epoch_loss_g = loss_g/ bi #total generator loss
    epoch_loss_d = loss_d / bi #total discriminator loss
    losses_d.append(epoch_loss_d)
    losses_g.append(epoch_loss_g)

    print(f"epoch {epoch} of {epochs}")
    print(f"Generator loss: {epoch_loss_g:.8f}, Discriminator loss: {epoch_loss_d:.8f}")      
print('DONE TRAINING')

#%% Saving the model and the images
torch.save(generator.state_dict(), '../Output/generator.pth')
# save the generated images as GIF file
imgs = [np.array(to_pil_image(img)) for img in images]
imageio.mimsave('../Output/generator_images.GIF', images)

#%%Plots
# plot and save the generator and discriminator loss
plt.figure()
plt.plot(losses_g, label='Generator loss')
plt.plot(losses_d, label='Discriminator Loss')
plt.legend()
plt.savefig('../Output/loss.png')